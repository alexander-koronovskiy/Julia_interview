# Установка и настройка окружения
в терминале пишем 'brew install julia'

## настройка в vscode
...

## первая программа
'println("Welcome to Julia")'

## исполнение julia при помощи консоли

### В корне проекта
julia -i hello.jl 

### с использованием переменной
julia -e "println(factorial(10))"

### выход из окружения
'ctrl+D'

### выход из окружения
']' - добавление пакетов

### Настройка ядра в Jypiter
делается простым переключением после установки

# О Julia

В Julia все является выражением, что означает, что практически всё в Julia возвращает значение. Это отличает Julia от многих других языков программирования, где есть различие между выражениями (что возвращает значение) и операторами (которые выполняют действия, но не обязательно возвращают значение).

Таким образом, в Julia почти любое действие или конструкция возвращает значение, которое затем может быть использовано в других выражениях. Например, даже присваивание переменной возвращает саму переменную, что позволяет вкладывать присваивания в цепочки выражений.

Кроме того, конструкции, такие как условные выражения (if-else), циклы (for, while) и объявления функций, также являются выражениями, и они могут использоваться в контексте, где требуется возврат значения. Это дает много гибкости при написании кода и позволяет более единообразно работать с различными типами данных и конструкциями.

Такая особенность Julia делает её очень мощным языком, который позволяет писать более компактный, гибкий, и часто более выразительный код.

# Решено
+ переопределение функций (перегрузка)
+ нов юпитер док (выбор компилятора)
+ chomp и readline это считывание
+ через запятую вывод в println
+ преобразование типов
+ базовая графика
+ срезы в массивах
+ словари (ворд-кантер)
+ url
+ ооп

# примеры задач
1. **Сортировка**: например, сортировка массива целых чисел или строк с использованием алгоритмов сортировки, таких как сортировка пузырьком, сортировка вставками, быстрая сортировка и сортировка слиянием. (+++)

2. **Поиск**: например, поиск элемента в массиве или поиск минимального/максимального элемента. Вы можете использовать алгоритмы поиска, такие как линейный поиск, бинарный поиск и другие. (+++)

3. **Обход графа**: реализация алгоритмов поиска в глубину и ширину, а также нахождение кратчайшего пути в графе.

4. **Динамическое программирование**: реализация алгоритмов динамического программирования для решения задач оптимизации, таких как рюкзаковая задача, нахождение наибольшей общей подпоследовательности и другие. (+++)

5. **Жадные алгоритмы**: реализация алгоритмов, которые делают локально оптимальные выборы в надежде на получение глобально оптимального решения. (+++)

6. **Структуры данных**: разработка и тестирование различных структур данных, таких как связанные списки, стеки, очереди, деревья и хеш-таблицы.

7. **Рекурсивные алгоритмы**: например, реализация рекурсивных функций для вычисления факториала, вычисления чисел Фибоначчи и других задач. (+++)